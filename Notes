DAY1

  OSI model 
    1. physical - hardware specifications, on/off switch, transmission/reception, encoding/signaling
    2. data link - where layer 1 devices communicate, uses MAC address, LLC
    3. network - (IP), headers basically. offsets n such
    4. transport - tcp/udp, 3-way handshake 
    5. session - maintatins connection,  
    6. presentation - translation, formatting, encoding, encryption, compression
    7. appllication - FTP, active/passive
  Stuff & Things 
    ssh - client/server authentication, symmetric session. data stream channeling, user/host - asymmetric
    sudo tcpdump "ether[12:2] = 0x800" -d *** berkeley packet fitler for something idk
    sudo tcpdump "tcp[13] & 0x01 = 0x01" *** packets with fin flag set
    i dont know what is going on fr
    
    switch - only destination MAC, fragment free - first 64 bytes, layer 2
          switch1#show mac address-table
          
    spanning tree protocol (STP) - elects root bridge, identifies root ports on non-root bridge, 
                                    and desig. port for each segment, alt ports to blocking state
    
    CDP - layer 2 discovery protocol
    Port security 0 shutdown, restrict, protect
    
    arpbroadcast=Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(op=1, pdst="172.16.82.115")
    arpspoofed=ARP(op=2, psrc="172.16.82.126", pdst="172.16.82.115", hwdst="fa:16:3e:24:20:44")
 
  Router Commands
    switch1#show mac-address table
    show ip route
    
    T1
Hostname: INTERNET_HOST
External IP: 10.50.XXX.XXX (ALREADY PROVIDED)
Internal IP: 10.10.0.40 (ALREADY PROVIDED)
creds: student:password
Action: Use as a pivot to access T2

T2
Hostname: BLUE_HOST-1
IP: 172.16.82.106
creds: student:password
Action: Successfully perform a ARP MitM using Scapy

T3
Hostname: BLUE_HOST-4
IP: 172.16.82.115
creds: (none)
Action: Suspected client recieving sensitive information

T4
Hostname: BLUE_POP-Router
IP: 172.16.82.126
creds: vyos:password
Action: Gateway of the network


DAY2
  Sockets & Such
    User Space - common, does not require priv esc. 
      nmap no switches, netcat, create listener above 1024, /dev/tcp(/udp) to transfer data
        stream - connection oriented, tcp ,sctp, bluetooth
        datagram - connectionless, speed, udp
    Kernel Space - used to prevent encap/decapsulation, require priv esc.
      tcpdump/wireshark to capture, nmap for enumeration, create lisenter -1023, scapy
        raw - direct in/out IP packets without auto protocol-specific formatting
    
    
    import socket
  s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)
  socket.socket([*family*[,*type*[*proto*]]])
  family constants should be: AF_INET (default), AF_INET6, AF_UNIX
  type constants should be: SOCK_STREAM (default), SOCK_DGRAM, SOCK_RAW
  proto constants should be: 0 (default), IPPROTO_RAW
  
  vim socketfile
  
    import socket 
    
    ipaddr = '127.0.0.1'
    port = 54321
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #SOCK_DGRAM for udp
    s.connect ((ipaddr, port)) #do not include for udp
    
    s.send(b'Hello\n') #, (ipaddr,port)) for udp
    
    response, conn = s.recvfrom(1024)
    
    print(response.decode())
    
    s.close()
    
    echo "hoes mad" | nc -l -p 54321
    
    
  raw socket creation
    import socket 
    import sys 
    from struct import *
    try :
        s - socket.socket(socket.AF_INET, socket.sock_RAW, socket.IPPROTO_RAW)
    except socket.error as msg:
        print(msg)
        sys.exit()
        
    packet = ''
    
    src_ip = "10.1.0.2"
    dst_ip = "10.3.0.2"
    
    ip_ver_ihl = 69
    ip_tos = 0
    ip_len = 0
    ip_id = 12345
    ip_frag = 0
    ip_ttl = 64
    ip_proto = 16
    ip_check = 0
    ip_srcadd = socket.inet_aton(src_ip)
    ip_dstadd = socket.inet_aton(dst_ip)
    
    ip_header = pack ('!BBHHHBBH4s4s',ip_ver_ih;, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
    
    tcp_src = 54321
    tcp_dst = 7777
    tcp_seq = 454
    tcp_ack_seq = 0
    tcp_data_off = 5
    tcp_reserve = 0
    tcp_flags = 0
    tcp_win = 65535
    tcp_chk = 0
    tcp_urg_ptr = 0
    
    tcp_off_res = (tcp_data_off << 4) + tcp_reserve
    
    tcp_fin = 0
    tcp_syn = 1
    tcp_rst = 0
    tcp_psh = 0
    tcp_ack = 0
    tcp_urg = 0
    tcp_ece = 0
    tcp_cwr = 0
    
    tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5) + (tcp_ece << 6) + (tcp_cwr << 7)
    
    tcp_hdr = pack('!HHLLBBHHH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win, tcp_chk, tcp_urg_ptr)
    
    user_data = b 'sumina humina'
    
    src_address = socket.inet_aton(src_ip)
    dst_address = socket.inet_aton(dst_ip)
    reserved = 0
    protocol = socket.IPPROTO_TCP
    tcp_length = len(tcp_hdr) + len(user_data)
    
    message = b'hoes mad, hoes mad'
    packet = ip_header + message
    
    s.sendto(packet, (dst_ip, 0))
    
    
    
ip[8]=1&&(ip[9]=1||ip[9]=17)
    
